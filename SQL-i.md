### Защита от SQL-инъекций. 

#### Введение

**Инъекция** - это такой тип хакерской атаки, который подразумевает внедрение в программу исполняемого кода злоумышленника.

В частности, **SQL-инъекция** - атака с внедрением SQL кода.

В данной статье мы рассмотрим эффективные методы и лучшие практики защиты от SQL-инъекций. Мы охватим не только теоретические аспекты, но и предоставим практические рекомендации по защите приложений

#### Природа SQL-инъекций: Разбор возможностей языка SQL

SQL-инъекции возникают из-за особенностей языка SQL, который используется для взаимодействия с базами данных. Эти уязвимости часто возникают от недостаточной обработки ввода данных в приложениях, что позволяет злоумышленникам внедрять вредоносный SQL-код. 
Рассмотрим, почему и как язык SQL может стать источником проблем и как это предотвратить.

#### Основы SQL-инъекций

SQL, как язык запросов, предоставляет удобные средства для взаимодействия с базами данных. Однако, когда приложения не обрабатывают входные данные должным образом, возникает риск SQL-инъекций. Злоумышленники могут использовать различные методы внедрения вредоносного кода, обманывая стандартные проверки и получая несанкционированный доступ к данным.

#### Механизмы SQL-инъекций

Рассмотрим главные ошибки программистов, которые позволяют злоумышленнику *плести коварные замыслы*.

#### 1. Некорректная экранизация данных

Если приложение не выполняет должную экранизацию специальных символов в пользовательском вводе, злоумышленник может внедрить дополнительные SQL-команды. Например, ввод `' OR '1'='1'; --` может привести к изменению смысла SQL-запроса и обходу проверки пароля.

#### 2. Слабые проверки ввода

Недостаточная валидация и фильтрация входных данных открывают двери для SQL-инъекций. Злоумышленник может вставить вредоносный код через различные параметры запросов, такие как формы, URL-параметры, cookies и т.п..

#### 3. Использование динамических запросов

Использование динамических SQL-запросов с конкатенацией строк также может способствовать SQL-инъекциям. Если значения пользователя вставляются в строку запроса без должной обработки, то это развязывает руки злоумышленнику.
Данная проблема является наиболее часто встречающейся.

#### Пример атаки с помощью SQL-инъекций

Итак, давайте рассмотрим пример того, как злоумышленник может атаковать наше приложение.

Рассмотрим приложение для покупок, которое отображает товары в различных категориях. Когда пользователь нажимает на категорию "Подарки", его браузер запрашивает URL-адрес:

	https://uhahatbltv.com/?category=Gifts

Это заставляет приложение выполнить SQL-запрос для получения информации о соответствующих товарах из базы данных:

```sql
SELECT * FROM products WHERE category = 'Gifts' AND released = 1
```
Ограничение released = 1 используется для скрытия продуктов, которые не выпущены. Для невыпущенных продуктов, предположительно, released = 0.

В приложении не реализована защита от атак SQL-инъекций, поэтому злоумышленник может построить атаку внедрив `--` в URL:


    https://uhahatbltv.com/products?category=Gifts'--


В результате получится SQL-запрос:

```sql
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

Ключевым моментом здесь является то, что последовательность двойных тире `--` является индикатором комментария в SQL и означает, что остальная часть запроса интерпретируется как комментарий. Это эффективно удаляет остаток запроса, так что он больше не включает AND released = 1. Это означает, что отображаются все продукты, включая еще не выпущенные.

Также, хакер может внедрить в URL следующее:

    https://uhahatbltv.com/products?category=Gifts' UNION SELECT username, password FROM users--

Тем самым, он выполнит следующий запрос в базе данных:

```sql
SELECT * FROM products WHERE category = 'Gifts' UNION SELECT username, password FROM users--' AND released = 1
```

И сможет получить доступ к учётным записям пользователей.

#### Предотвращение SQL-инъекций

Чтобы защититься от SQL-инъекций, необходимо активно применять методы, такие как параметризация запросов, использование хранимых процедур, ORM и Web Application Firewall (WAF).

#### Основы защиты от SQL-инъекций

#### 1. Параметризация запросов

**Параметризация запросов** заставляет разработчика сначала определить весь код SQL, а затем передать каждый параметр в запрос. Это позволяет БД различать код и данные независимо от того, что вводится пользователем. Подготовленные операторы гарантируют, что злоумышленник не сможет изменить логику запроса, даже, если атакующий вставляет команды SQL. Правильно параметризированный запрос не позволит базе данных обработать информацию о пользователе, как часть SQL-запроса. 


```sql
-- Пример безопасного запроса
SELECT * FROM users WHERE username = @Username AND password = @Password;
```

```java
// Пример применения параметризированного запроса на языке C#
public IEnumerable<User> FindByEmail (string user, string pass)
{
using (var connection = DBConnection.CreateConnection()) { return connection. Query<User>(
"SELECT * FROM users WHERE username = @Username AND password = @Password;", new { Username = user, Password = pass});
}
}
```
#### 2. Использование хранимых процедур

**Хранимые процедуры** представляют собой еще один важный механизм защиты от SQL-инъекций.  Объекты базы данных требуют, чтобы разработчик сгруппировал один или несколько операторов SQL в логическую единицу для создания плана выполнения. Последующие исполнения позволяют автоматически параметризовать операторы. То есть, это тип кода, который можно сохранить и многократно использовать в последующем. Когда необходимо выполнить запрос, вместо того, чтобы писать его, можно будет вызвать хранимую процедуру.

По сути своей, хранимые процедуры реализуют всё ту же параметризацию, но объявляются не в приложении, а в СУБД. 


```sql
-- Пример хранимой процедуры
CREATE OR REPLACE FUNCTION check_user_credentials(
    in_username VARCHAR(50),
    in_password VARCHAR(50)
)
RETURNS TABLE (
    user_id INT,
    username VARCHAR(50),
    email VARCHAR(100)
)
AS $$
BEGIN
    RETURN QUERY
    SELECT user_id, username, email
    FROM users
    WHERE username = in_username AND password = in_password;
END;
$$ LANGUAGE plpgsql;
```
#### 3. WAF

**Web Application Firewall** (WAF) - это универсальное решение, которое работает на уровне веб-сервера, позволяющее блокировать попытки эксплуатации различных типов уязвимостей, в том числе и SQL-инъекции. В основе своей работы WAF использует машинное обучение, способное более точно и с минимальным количеством ложных срабатываний, противодействовать атакам на веб-приложение вне зависимости от языка разработки и используемых фреймворков.

Казалось бы, почему нельзя всецело довериться этому механизму?
Оказалось, он далеко не идеален и через него может пройти инъекция от опытного хакера.

**Вот пример того, как можно обойти защиту WAF:**

Комментарии + пробелы + случайный регистр + шестнадцатеричные значения в URL-кодировании - вот та самая зловещая формула обхода.

Давайте мы её применим на практике.

Разбавляем нашу инъекцию встроенными комментариями, такими как `/*comment*/`. 
Объединяем это с альтернативой для пробелов, используя `/**/`, добавляем рандомизированный регистр и заменяем некоторые символы на их шестнадцатеричные значения в кодировке UTF-8 в URL.

И такой простой запрос как :

```sql
UNION SELECT password FROM...
```
Будет выглядеть как : 

```
/*!98765%75Nio%4e*//**//*!%73eL%65cT*//**/p%41sSw%6fRd/**/fR%4fM...
```

Таким образом мы доказали, что всецело полагаться на лишь один механизм защиты нельзя.

#### 4. ORM

**Object-Relational Mapping** (ORM) - это технология, которая связывает объекты в программировании с записями в реляционных базах данных. Она позволяет разработчикам работать с объектами в коде, избегая прямых SQL-запросов и предоставляя абстракцию для работы с базой данных.

По сути, является прослойкой между приложением и СУБД.

ORM довольно распространённый подход и разработчики довольно часто пользуются им для написания больших приложений.

ORM также имеет защиту от SQL-инъекций.
Он генерирует простые запросы к базе данных, которые автоматически параметризованные и экранированные.

Однако, не стоит так полагаться на ORM.
Он имеет ряд недостатков, которые очень часто совершают начинающие разработчики, которые до этого не пользовались хотя-бы JDBC и его аналогами.

1. ORM не умеет генерировать сложные запросы и поэтому написание этих запросов ложится полностью на программиста. Отсюда, и защита также ложится на плечи разработчика, поскольку ORM не предоставляет таких инструментов, которые автоматически параметризуют и экранируют SQL код.

Пример создания своего запроса, подверженного SQL-инъекциям:

```java
import org.hibernate.Session;
import org.hibernate.query.Query;

public class VulnerableORMQueryExample {

    public User getUserByUsernameAndPassword(String username, String password) {
        Session session = HibernateUtil.getSessionFactory().openSession();
        try {
            //Использование конкатенации строк категорически запрещено
            String queryString = "FROM User WHERE username = '" + username + "' AND password = '" + password + "'";
            
            Query<User> query = session.createQuery(queryString, User.class);
            return query.uniqueResult();
        } finally {
            session.close();
        }
    }
}

```

2. Фреймворки ORM время от времени склонны к появлению уязвимостей, как и любой другой программный пакет, поэтому необходимо выполнять различные дополнительные практики безопасности.

#### Подводим итоги

SQL-инъекции всё ещё представляют опасность в наши дни и необходимо осведомить всех разработчиков и обратить их внимание на эту проблему.

Рекомендуется проводить тренинги с сотрудникам касательно этой проблемы и глубже разобраться в этой проблеме, чтобы в дальнейшем избежать больших сбоев в программном обеспечении, материальных убытков и проблем с законом.

В данной статье мы рассмотрели несколько основных интсрументов для защиты от SQL-инъекций и можем прийти к выводу, что программист не должен полагаться на одно средство защиты, а должен уметь комбинировать подходы и *хорошо знать врага в лицо*.

Спасибо за внимание!





